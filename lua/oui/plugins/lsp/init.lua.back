-- TODO: jdtls (https://github.com/VonHeikemen/lsp-zero.nvim/blob/v3.x/doc/md/guides/setup-with-nvim-jdtls.md)
local set_lsp_telescope_mappings = function(bufnr)
  local opts = { buffer = bufnr, remap = false, silent = true }
  local set = vim.keymap.set
  set(
    "n",
    "<leader>lr",
    "<cmd>Telescope lsp_references<cr>",
    { buffer = bufnr, remap = false, silent = true, desc = "LSP references" }
  )
  set(
    "n",
    "<leader>lS",
    "<cmd>Telescope lsp_workspace_symbols<cr>",
    { buffer = bufnr, remap = false, silent = true, desc = "LSP symbols" }
  )
  set(
    "n",
    "<leader>li",
    "<cmd>Telescope lsp_implementations<cr>",
    { buffer = bufnr, remap = false, silent = true, desc = "LSP implementation" }
  )
  set(
    "n",
    "<leader>le",
    "<cmd>Telescope diagnostics<cr>",
    { buffer = bufnr, remap = false, silent = true, desc = "LSP diagnostics" }
  )
end

local set_lsp_mappings = function(bufnr)
  local set = vim.keymap.set

  set_lsp_telescope_mappings(bufnr)

  -- set("n", "<leader>ld", function()
  -- 	vim.lsp.buf.definition()
  -- end, { buffer = bufnr, remap = false, silent = true, desc = "LSP definition" })
  set("n", "<leader>lD", function()
    vim.lsp.buf.declaration()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP declaration" })
  set("n", "<leader>lh", function()
    vim.lsp.buf.hover()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP hover info" })
  set("n", "<leader>lf", function()
    vim.diagnostic.open_float()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP diagnostic" })
  set("n", "<leader>lj", function()
    vim.diagnostic.goto_next()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP next diagnostic" })
  set("n", "<leader>lk", function()
    vim.diagnostic.goto_prev()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP prev diagnostic" })
  set("n", "<leader>la", function()
    vim.lsp.buf.code_action()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP code action" })
  set("n", "<leader>lR", function()
    vim.lsp.buf.rename()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP rename" })
  set("n", "<leader>lS", function()
    vim.lsp.buf.signature_help()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP signature help" })
end

local set_lspsaga_mappings = function(bufnr)
  local opts = { buffer = bufnr, remap = false, silent = true }
  local set = vim.keymap.set
  set_lsp_telescope_mappings(bufnr)
  -- local lspsaga = require("lspsaga")

  set(
    "n",
    "<A-d>",
    "<cmd>Lspsaga term_toggle<cr>",
    { buffer = bufnr, remap = false, silent = true, desc = "Terminal" }
  )
  set(
    "n",
    "<leader>ld",
    "<cmd>Lspsaga peek_definition<cr>",
    { buffer = bufnr, remap = false, silent = true, desc = "LSP definition" }
  )
  set("n", "<leader>lD", function()
    vim.lsp.buf.declaration()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP declaration" })
  set("n", "<leader>lh", function()
    vim.cmd("Lspsaga hover_doc")
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP hover info" })
  set("n", "<leader>lf", function()
    vim.diagnostic.open_float()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP diagnostic" })
  set("n", "<leader>lj", function()
    vim.cmd("Lspsaga diagnostic_jump_next")
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP next diagnostic" })
  set("n", "<leader>lk", function()
    vim.cmd("Lspsaga diagnostic_jump_prev")
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP prev diagnostic" })
  set("n", "<leader>la", function()
    vim.cmd("Lspsaga code_action")
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP code action" })
  set("n", "<leader>lR", function()
    vim.cmd("Lspsaga rename")
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP rename" })
  set("n", "<leader>lS", function()
    vim.lsp.buf.signature_help()
  end, { buffer = bufnr, remap = false, silent = true, desc = "LSP signature help" })
end

local M = {
  "neovim/nvim-lspconfig",
  cmd = { "LspInfo", "LspInstall", "LspStart" },
  event = { "BufReadPre", "BufNewFile" },
  dependencies = {
    { "hrsh7th/cmp-nvim-lsp", "nvimdev/lspsaga.nvim" },
  },
  config = function()
    -- some ricing before setting up LSP:
    vim.diagnostic.config({
      virtual_text = false,
      update_in_insert = false,
      underline = true,
      severity_sort = true,
      float = {
        source = "if_many",
      },
    })

    local lspsaga = require("lspsaga")
    local capabilities = require("cmp_nvim_lsp").default_capabilities()
    local on_attach = function(_, bufnr)
      set_lspsaga_mappings(bufnr)
    end

    require("lspconfig").lua_ls.setup({
      on_init = function(client)
        local path = client.workspace_folders[1].name
        if vim.loop.fs_stat(path .. "/.luarc.json") or vim.loop.fs_stat(path .. "/.luarc.jsonc") then
          return
        end

        client.config.settings.Lua = vim.tbl_deep_extend("force", client.config.settings.Lua, {
          runtime = {
            -- Tell the language server which version of Lua you're using
            -- (most likely LuaJIT in the case of Neovim)
            version = "LuaJIT",
          },
          -- Make the server aware of Neovim runtime files
          workspace = {
            checkThirdParty = false,
            library = {
              vim.env.VIMRUNTIME,
              -- Depending on the usage, you might want to add additional paths here.
              -- "${3rd}/luv/library"
              -- "${3rd}/busted/library",
            },
            -- or pull in all of 'runtimepath'. NOTE: this is a lot slower
            -- library = vim.api.nvim_get_runtime_file("", true)
          },
        })
      end,
      settings = { Lua = {} },
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").html.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").cssls.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").bashls.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").nixd.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").emmet_language_server.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").tailwindcss.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").ruff_lsp.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").volar.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    require("lspconfig").intelephense.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })
    -- require("lspconfig").tsserver.setup({
    --   on_attach = on_attach,
    --   capabilities = capabilities,
    -- })

    require("lspconfig").gopls.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })

    -- clangd: special settings:
    require("lspconfig").clangd.setup({
      cmd = {
        "clangd",
        "--background-index",
        "--clang-tidy",
        "--header-insertion=iwyu",
        "--completion-style=detailed",
        "--function-arg-placeholders",
        "--fallback-style=llvm",
        "--offset-encoding=utf-16",
      },
      on_attach = function(_, bufnr)
        set_lspsaga_mappings(bufnr)
        vim.keymap.set("n", "<leader>ls", function()
          vim.cmd("ClangdSwitchSourceHeader")
        end, { buffer = bufnr, remap = false, silent = true, desc = "ClangdSwitchSourceHeader" })
      end,
    })

    require("lspconfig").cmake.setup({
      on_attach = on_attach,
      capabilities = capabilities,
    })

    require("lspconfig").volar.setup({
      init_options = {
        vue = {
          hybridMode = true,
        },
      },
    })

    require("lspconfig").vtsls.setup({
      -- them in related extras
      capabilities = capabilities,
      filetypes = {
        "javascript",
        "javascriptreact",
        "javascript.jsx",
        "typescript",
        "typescriptreact",
        "typescript.tsx",
        "vue",
      },
      settings = {
        complete_function_calls = true,
        vtsls = {
          enableMoveToFileCodeAction = true,
          autoUseWorkspaceTsdk = true,
          experimental = {
            completion = {
              enableServerSideFuzzyMatch = true,
            },
          },
          tsserver = {
            globalPlugins = {
              {
                name = "@vue/typescript-plugin",
                -- location = "/home/naim/.npm-packages/bin/vue-language-server",
                -- location = "/home/naim/.npm-packages/lib/node_modules/@vue/language-server",
                languages = { "vue" },
                configNamespace = "typescript",
                enableForWorkspaceTypeScriptVersions = true,
              },
            },
          },
        },
        typescript = {
          updateImportsOnFileMove = { enabled = "always" },
          suggest = {
            completeFunctionCalls = true,
          },
          inlayHints = {
            enumMemberValues = { enabled = true },
            functionLikeReturnTypes = { enabled = true },
            parameterNames = { enabled = "literals" },
            parameterTypes = { enabled = true },
            propertyDeclarationTypes = { enabled = true },
            variableTypes = { enabled = false },
          },
        },
      },

      on_attach = function(client, buffer)
        client.commands["_typescript.moveToFileRefactoring"] = function(command, ctx)
          ---@type string, string, lsp.Range
          local action, uri, range = unpack(command.arguments)

          local function move(newf)
            client.request("workspace/executeCommand", {
              command = command.command,
              arguments = { action, uri, range, newf },
            })
          end

          local fname = vim.uri_to_fname(uri)
          client.request("workspace/executeCommand", {
            command = "typescript.tsserverRequest",
            arguments = {
              "getMoveToRefactoringFileSuggestions",
              {
                file = fname,
                startLine = range.start.line + 1,
                startOffset = range.start.character + 1,
                endLine = range["end"].line + 1,
                endOffset = range["end"].character + 1,
              },
            },
          }, function(_, result)
            ---@type string[]
            local files = result.body.files
            table.insert(files, 1, "Enter new path...")
            vim.ui.select(files, {
              prompt = "Select move destination:",
              format_item = function(f)
                return vim.fn.fnamemodify(f, ":~:.")
              end,
            }, function(f)
              if f and f:find("^Enter new path") then
                vim.ui.input({
                  prompt = "Enter move destination:",
                  default = vim.fn.fnamemodify(fname, ":h") .. "/",
                  completion = "file",
                }, function(newf)
                  return newf and move(newf)
                end)
              elseif f then
                move(f)
              end
            end)
          end)
        end
      end,
    })

    -- require("lspconfig").glsl_analyzer.setup({})
  end,
}

return M
